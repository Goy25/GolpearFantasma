<!DOCTYPE html>
<html lang="es">
  <head>
    <title>WebGL 2.0</title>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <style>
      .campo {
        padding: 10px;
        display: flex;
        max-height: 20px;
        align-items: center;
      }

      #puntuacion {
        margin-right: 5px;
      }

      label {
        width: 220px;
        margin-right: 5px;
      }

      input[type="number"] {
        width: 40px;
      }
    </style>
  </head>
  <body>
    <h2>Golpear fantasmas</h2>
    <div class="campo">
      <p style="margin-right: 5px;">Puntuacion: </p>
      <p id="puntuacion">0</p>
      <button id="jugar" onclick="ejecutar()">Jugar</button>
    </div>
    <div class="campo">
      <div class="campo">
        <label>Cantidad de fantasmas: </label>
        <input type="number" value="5" id="cFant"  onchange="valCFantasmas()">
      </div>
      <div class="campo">
        <label>Tiempo de juego (seg): </label>
        <input type="number" value="30" id="cTiempo" onchange="valTJuego()">
      </div>
    </div>
    <div class="campo">
      <div class="campo">
        <label>Cantidad de Reemplazos: </label>
        <input type="number" value="1" id="cReemp" onchange="valCReemp()">
      </div>
      <div class="campo">
        <label>Tiempo entre Reemplazos (seg): </label>
        <input type="number" value="1" id="tReemp" onchange="valTReemp()">
      </div>
    </div>
    <canvas id="webglcanvas" style="border: none" width="500" height="500">
    </canvas>
    <p>Por: Goyzueta Merida Adrian Matis</p>

    <!-- Paso 1. Se definen los shaders -->
    <script id="vs" type="vertex">
      #version 300 es
      uniform mat4 uMatrizProyeccion;
      uniform mat4 uMatrizVista;
      uniform mat4 uMatrizModelo;
      layout(location = 0) in vec2 aVertices;
      layout(location = 1) in vec4 aColores;
      out vec4 vColores;
      void main() {
          vColores = aColores;
          gl_Position = uMatrizProyeccion * uMatrizVista * uMatrizModelo * vec4(aVertices, 0.0, 1.0);
      }
    </script>

    <script id="fs" type="fragment">
      #version 300 es
      precision mediump float;
      in vec4 vColores;
      out vec4 color;
      void main() {
          color = vColores;
      }
    </script>

    <script>
      /***************************************************************************/
      /* Transformaciones mediante matrices                                      */
      /***************************************************************************/

      /* Convierte de grados a radianes */
      function toRadians(grados) {
        return (grados * Math.PI) / 180;
      }

      /* Matriz Identidad */
      function identidad(r) {
        r[0] = 1;
        r[4] = 0;
        r[8] = 0;
        r[12] = 0;
        r[1] = 0;
        r[5] = 1;
        r[9] = 0;
        r[13] = 0;
        r[2] = 0;
        r[6] = 0;
        r[10] = 1;
        r[14] = 0;
        r[3] = 0;
        r[7] = 0;
        r[11] = 0;
        r[15] = 1;
      }

      /* Traslación - glTranslatef */
      function traslacion(matriz, tx, ty, tz) {
        var r = new Array(16);
        r[0] = 1;
        r[4] = 0;
        r[8] = 0;
        r[12] = tx;
        r[1] = 0;
        r[5] = 1;
        r[9] = 0;
        r[13] = ty;
        r[2] = 0;
        r[6] = 0;
        r[10] = 1;
        r[14] = tz;
        r[3] = 0;
        r[7] = 0;
        r[11] = 0;
        r[15] = 1;
        multiplica(matriz, matriz, r);
      }

      /* Escalación - glScalef */
      function escalacion(matriz, sx, sy, sz) {
        var r = new Array(16);
        r[0] = sx;
        r[4] = 0;
        r[8] = 0;
        r[12] = 0;
        r[1] = 0;
        r[5] = sy;
        r[9] = 0;
        r[13] = 0;
        r[2] = 0;
        r[6] = 0;
        r[10] = sz;
        r[14] = 0;
        r[3] = 0;
        r[7] = 0;
        r[11] = 0;
        r[15] = 1;
        multiplica(matriz, matriz, r);
      }

      /* Rotación sobre X - glRotatef */
      function rotacionX(matriz, theta) {
        let r = new Array(16);
        var c = Math.cos(toRadians(theta));
        var s = Math.sin(toRadians(theta));
        r[0] = 1;
        r[4] = 0;
        r[8] = 0;
        r[12] = 0;
        r[1] = 0;
        r[5] = c;
        r[9] = -s;
        r[13] = 0;
        r[2] = 0;
        r[6] = s;
        r[10] = c;
        r[14] = 0;
        r[3] = 0;
        r[7] = 0;
        r[11] = 0;
        r[15] = 1;
        multiplica(matriz, matriz, r);
      }

      /* Rotación sobre Y - glRotatef */
      function rotacionY(matriz, theta) {
        let r = new Array(16);
        var c = Math.cos(toRadians(theta));
        var s = Math.sin(toRadians(theta));
        r[0] = c;
        r[4] = 0;
        r[8] = s;
        r[12] = 0;
        r[1] = 0;
        r[5] = 1;
        r[9] = 0;
        r[13] = 0;
        r[2] = -s;
        r[6] = 0;
        r[10] = c;
        r[14] = 0;
        r[3] = 0;
        r[7] = 0;
        r[11] = 0;
        r[15] = 1;
        multiplica(matriz, matriz, r);
      }

      /* Rotación sobre Z - glRotatef */
      function rotacionZ(matriz, theta) {
        let r = new Array(16);
        var c = Math.cos(toRadians(theta));
        var s = Math.sin(toRadians(theta));
        r[0] = c;
        r[4] = -s;
        r[8] = 0;
        r[12] = 0;
        r[1] = s;
        r[5] = c;
        r[9] = 0;
        r[13] = 0;
        r[2] = 0;
        r[6] = 0;
        r[10] = 1;
        r[14] = 0;
        r[3] = 0;
        r[7] = 0;
        r[11] = 0;
        r[15] = 1;
        multiplica(matriz, matriz, r);
      }

      /* Proyección Paralela - glOrtho */
      function ortho(r, izq, der, abj, arr, cerca, lejos) {
        r[0] = 2 / (der - izq);
        r[4] = 0;
        r[8] = 0;
        r[12] = -(der + izq) / (der - izq);
        r[1] = 0;
        r[5] = 2 / (arr - abj);
        r[9] = 0;
        r[13] = -(arr + abj) / (arr - abj);
        r[2] = 0;
        r[6] = 0;
        r[10] = -2 / (lejos - cerca);
        r[14] = -(lejos + cerca) / (lejos - cerca);
        r[3] = 0;
        r[7] = 0;
        r[11] = 0;
        r[15] = 1;
      }

      /* Proyección Perspectiva - glFrustum */
      function frustum(r, izq, der, abj, arr, cerca, lejos) {
        r[0] = (2 * cerca) / (der - izq);
        r[4] = 0;
        r[8] = (der + izq) / (der - izq);
        r[12] = 0;
        r[1] = 0;
        r[5] = (2 * cerca) / (arr - abj);
        r[9] = (arr + abj) / (arr - abj);
        r[13] = 0;
        r[2] = 0;
        r[6] = 0;
        r[10] = -(lejos + cerca) / (lejos - cerca);
        r[14] = (-2 * lejos * cerca) / (lejos - cerca);
        r[3] = 0;
        r[7] = 0;
        r[11] = -1;
        r[15] = 0;
      }

      /* Proyección Perspectiva - gluPerspective */
      function perspective(r, fovy, aspecto, cerca, lejos) {
        var ang = fovy * 0.5;
        var f =
          (Math.abs(Math.sin(toRadians(ang))) < 1e-8 ? 0 : 1) /
          Math.tan(toRadians(ang));
        r[0] = f / aspecto;
        r[4] = 0;
        r[8] = 0;
        r[12] = 0;
        r[1] = 0;
        r[5] = f;
        r[9] = 0;
        r[13] = 0;
        r[2] = 0;
        r[6] = 0;
        r[10] = -(lejos + cerca) / (lejos - cerca);
        r[14] = (-2.0 * lejos * cerca) / (lejos - cerca);
        r[3] = 0;
        r[7] = 0;
        r[11] = -1.0;
        r[15] = 0;
      }

      /* Multiplicación de matrices de 4 x 4 */
      function multiplica(c, a, b) {
        let r = new Array(16);
        let i, j, k;
        for (i = 0; i < 4; i++) {
          for (j = 0; j < 4; j++) {
            let s = 0;
            for (k = 0; k < 4; k++) s = s + a[i + k * 4] * b[k + j * 4];
            r[i + j * 4] = s;
          }
        }
        for (i = 0; i < 16; i++) c[i] = r[i];
      }

      var canvas, gl, fantasmas, cantFantasmas, posiciones, tJuego, tReemp, cReemp;
      var intervalo, puntuacion = 0;
      const jugar = document.getElementById("jugar"), marcador = document.getElementById("puntuacion");

      function valCFantasmas () {
        cantFantasmas = parseInt(document.getElementById("cFant").value);
        if (cantFantasmas < 1) {
          document.getElementById("cFant").value = 1;
        }
        valCReemp();
      }

      function valTJuego () {
        tJuego = parseInt(document.getElementById("cTiempo").value);
        if (tJuego < 5) {
          document.getElementById("cTiempo").value = 5;
        }
      }

      function valTReemp () {
        tReemp = parseInt(document.getElementById("tReemp").value);
        if (tReemp < 1) {
          document.getElementById("tReemp").value = 1;
        }
      }

      function valCReemp () {
        cantFantasmas = parseInt(document.getElementById("cFant").value);
        cReemp = parseInt(document.getElementById("cReemp").value);
        if (cReemp < 1) {
          document.getElementById("cReemp").value = 1;
        }
        if (cReemp > cantFantasmas) {
          document.getElementById("cReemp").value = cantFantasmas;
        }
      }

      function fantasma (x, y) {
        var fantasma = new Array(1808);
        fantasma[0] = x; fantasma[1] = y;
        fantasma[2] = x+2; fantasma[3] = y;
        fantasma[4] = x+2; fantasma[5] = y+2;
        fantasma[6] = x; fantasma[7] = y+2;
        let a = x + 1, b = y + 2;
        for (let i=8; i<368; i+=2) {
          let cos = Math.cos((i-8) * Math.PI / 180);
          let sen = Math.sin((i-8) * Math.PI / 180);
          fantasma[i] = a + cos;
          fantasma[i+1] = b + sen;
        }
        for (let i=368; i<1088; i+=2) {
          let cos = Math.cos((i-8) * Math.PI / 180);
          let sen = Math.sin((i-8) * Math.PI / 180);
          fantasma[i] = a + 0.4 + 0.2 * cos;
          fantasma[i+1] = b + 0.2 + 0.2 * sen;
          fantasma[i+720] = a - 0.4 + 0.2 * cos;
          fantasma[i+721] = b + 0.2 + 0.2 * sen;
        }

        var colores = new Array(3616);

        for (let i=0; i<736; i+=4) {
          colores[i] = 1;
          colores[i+1] = 1;
          colores[i+2] = 1;
          colores[i+3] = 1;
        }

        for (let i=736; i<3616; i+=4) {
          colores[i] = 0;
          colores[i+1] = 0;
          colores[i+2] = 0;
          colores[i+3] = 1;
        }

        var fantasmaVAO = gl.createVertexArray();
        gl.bindVertexArray(fantasmaVAO);

        var codigoVertices = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(fantasma),
          gl.STATIC_DRAW
        );
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

        var codigoColores = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, codigoColores);
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(colores),
          gl.STATIC_DRAW
        );
        gl.enableVertexAttribArray(1);
        gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

        gl.bindVertexArray(null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);

        gl.bindVertexArray(fantasmaVAO);
        gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
        gl.drawArrays(gl.TRIANGLE_FAN, 4, 180);
        gl.drawArrays(gl.TRIANGLE_FAN, 184, 360);
        gl.drawArrays(gl.TRIANGLE_FAN, 544, 360);
        gl.bindVertexArray(null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
      }

      function graficarFantasmas(pos) {
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
        for (let i=0; i<cantFantasmas*2; i+=2) {
          fantasma(pos[i], pos[i+1]);
        }
      }

      function esconder() {
        for (let i = cantFantasmas - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [posiciones[i], posiciones[j]] = [posiciones[j], posiciones[i]];
        }
        for (let i = 0; i < cReemp; i++) {
          fantasmas[posiciones[i]*2] = Math.random() * 18 - 10;
          fantasmas[posiciones[i]*2+1] = Math.random() * 17 - 10;
        }
        graficarFantasmas(fantasmas);
      }
      
      function ejecutar () {
        puntuacion = 0;
        marcador.textContent = puntuacion;
        cantFantasmas = parseInt(document.getElementById("cFant").value);
        tJuego = parseInt(document.getElementById("cTiempo").value) * 1000;
        tReemp = parseInt(document.getElementById("tReemp").value) * 1000;
        cReemp = parseInt(document.getElementById("cReemp").value);
        posiciones = Array.from({ length: cantFantasmas }, (_, index) => index);
        fantasmas = new Array(cantFantasmas * 2);
        for (let i=0; i<cantFantasmas*2; i+=2) {
          let x = Math.random() * 18 - 10;
          let y = Math.random() * 17 - 10;
          fantasmas[i] = x;
          fantasmas[i+1] = y;
        }
        graficarFantasmas(fantasmas)
        jugar.disabled = true;
        intervalo = setInterval(esconder, tReemp);
        setTimeout(function() {
          clearInterval(intervalo);
          jugar.disabled = false;
        }, tJuego);
      }

      function puntoEstaDentroDelRectangulo(posx, posy, x, y) {
        let x2 = x + 2;
        let y2 = y + 2;
        return x < posx && posx < x2 && y < posy && posy < y2;
      }

      function puntoEstaDentroDelCirculo(posx, posy, x, y) {
        var d = Math.pow(x - posx, 2) + Math.pow(y - posy, 2);
        return d < 1;
      }

      function mouseDown(e) {
        if (jugar.disabled){
          var posx = (e.x - canvas.offsetLeft) / 25 - 10;
          var posy = (-e.y + canvas.offsetTop) / 25 + 10;
          for (let i=0; i<cantFantasmas*2; i+=2) {
            if (puntoEstaDentroDelRectangulo(posx, posy, fantasmas[i], fantasmas[i+1]) || puntoEstaDentroDelCirculo(posx, posy, fantasmas[i]+1, fantasmas[i+1]+2)) {
              puntuacion++;
              marcador.textContent = puntuacion;
              fantasmas[i] = Math.random() * 18 - 10;
              fantasmas[i+1] = Math.random() * 17 - 10;
              graficarFantasmas(fantasmas);
              break
            }
          }
        }
      }

      function main() {
        // Paso 2. Generamos el lienzo
        canvas = document.getElementById("webglcanvas");
        gl = canvas.getContext("webgl2", { antialias: true });
        if (!gl) {
          document.write("No funciona el webgl 2.0");
          return;
        }

        canvas.addEventListener("mousedown", mouseDown, false);

        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

        // Paso 3: Compilar y enlazar los shaders
        var shaderDeVertice = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(
          shaderDeVertice,
          document.getElementById("vs").text.trim()
        );
        gl.compileShader(shaderDeVertice);

        var shaderDeFragmento = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(
          shaderDeFragmento,
          document.getElementById("fs").text.trim()
        );
        gl.compileShader(shaderDeFragmento);

        var programaID = gl.createProgram();
        gl.attachShader(programaID, shaderDeVertice);
        gl.attachShader(programaID, shaderDeFragmento);
        gl.linkProgram(programaID);

        gl.useProgram(programaID);

        var uMatrizProyeccion;
        var uMatrizVista;
        var uMatrizModelo;

        var MatrizProyeccion = new Array(16);
        var MatrizVista = new Array(16);
        var MatrizModelo = new Array(16);

        uMatrizProyeccion = gl.getUniformLocation(
          programaID,
          "uMatrizProyeccion"
        );
        uMatrizVista = gl.getUniformLocation(programaID, "uMatrizVista");
        uMatrizModelo = gl.getUniformLocation(programaID, "uMatrizModelo");

        ortho(MatrizProyeccion, -10, 10, -10, 10, -10, 10);
        gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);

        identidad(MatrizVista);
        gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);

        identidad(MatrizModelo);
        gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
      }
      window.onload = main;
    </script>
  </body>
</html>
